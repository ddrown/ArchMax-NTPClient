lwip notes:
 lwip's NO_SYS mode - no threading
 uart write is blocking, so that slows down ping
 LwIP heap in lwip/opt.h: #define MEM_SIZE 1600
  = 200039ac 00000653 B ram_heap
 Packet buffer in lwip/opt.h:
  #define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(590)
  #define PBUF_POOL_SIZE                  16
  16*590 = 9440
  actual = 9731
  = 20004210 00002603 B memp_memory_PBUF_POOL_base
 Src/ethernetif.c has the Tx and Rx descriptors for DMA:
  = 20000908 000017d0 B Rx_Buff
  = 200021a0 000017d0 B Tx_Buff


Src/ethernetif - low level ethernet adapter
 low_level_init - mac address and PHY
  - no real mac address assigned to these boards
  - microchip sells i2c eeproms with EUI48s built in for $0.25/1
 low_level_output - copy pbuf into dma txdesc
 low_level_input - copy dma rxdesc into pbuf (uses polling GetReceivedFrame)
 ethernetif_input - calls low_level_input, then netif->input
 ethernetif_update_config - called on link change (disabled)

Src/lwip - adapter to lwip above ethernetif
 MX_LWIP_Init - setup
 MX_LWIP_Process - call in main loop to rx and check timers

Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_eth.c
 HAL_ETH_GetReceivedFrame - polling
 HAL_ETH_GetReceivedFrame_IT - interrupt
__weak void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
__weak void HAL_ETH_TxCpltCallback(ETH_HandleTypeDef *heth)
__weak void HAL_ETH_ErrorCallback(ETH_HandleTypeDef *heth)

dma notes:
DMA checks the descriptor status?
      dmarxdesc->Status |= ETH_DMARXDESC_OWN;
      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
RX and TX buffers are circular linked lists?
OSF (SecondFrameOperate) is enabled

timestamp choices:
 pbuf?
 handle the packet directly in low_level_input?
 This PTP trigger signal is connected to the TIM2 ITR1 input selectable by software. The connection is enabled through bits 11 and 10 in the TIM2 option register (TIM2_OR)
 RX: ETH_PTPTSCR_TSE
 TX: ETH_DMATXDESC_TTSE
 Clock is 168MHz
 TSSIPV4FE: Time stamp snapshot for IPv4 frames enable - When this bit is set, the time stamp snapshot is taken for IPv4 frames.
 TSSIPV6FE: Time stamp snapshot for IPv6 frames enable - When this bit is set, the time stamp snapshot is taken for IPv6 frames.
 TSSSR: Time stamp subsecond rollover: digital or binary rollover control - rollover at 999,999,999 (set) or 0x7FFFFFFF (clear)
 TSSARFE: Time stamp snapshot for all received frames enable - When this bit is set, the time stamp snapshot is enabled for all frames received by the core
 TSARU: Time stamp addend register update - fine correction
 TSSTU: Time stamp system time update - corse correction
 TSSTI: Time stamp system time initialize
 TSFCU: Time stamp fine or coarse update
 TSE: Time stamp enable - enable/disable system
 ETH_PTPSSIR - subsecond increment amount 5.952ns/(1000000000ns/2^31counts) = 12.781822672916,   13 = .000000006053
 ETH_PTPTSHR - seconds
 ETH_PTPTSLR - subseconds (bit 31 = +/-)
 ETH_PTPTSHUR - seconds init/update
 ETH_PTPTSLUR - subsecond init/update (bit 31 = set- clear+)
 ETH_PTPTSAR - fine adjust (in 2^32 overflows per 20ns) 2^32*50MHz/66MHz = 3253763103 (for 66MHz system clock)
2^32 overflow per 6.053ns at 168MHz
(1/.000000006053*2^32)/168000000 = 4223572034.331657658931

6.053ns/tick
1/.000000006053 = 165207335.205683132331 Hz
4223572034 increment at 168MHz, overflows 32 bit at:
168000000*4223572034/2^32 = 165207335.192710161209 Hz

 ETH_PTPTTHR - target time high
 ETH_PTPTTLR - target time low
 


PHY notes:
 AN0/AN1 are configured for half-duplex mode by default, code has to change that for full duplex
 DP83848J - http://www.ti.com/lit/ds/symlink/dp83848j.pdf

interrupts at 100kpps in + out are a problem
should tx timestamps be used?
should per client stats be gathered?
how to report stat data - tcp?
GPS data & parsing
PPS aligned with NIC timestamps
NIC timestamps in NTP timescale?
NIC clock control adjustments
NTP root delay and dispersion calculation
TX timestamps used to measure DMA delay and then assume it's constant?
how do multiple packets work with DMA - one at a time?
100kpps = around 1790 cycles per packet (10us)
ddos amplification?
  uint32_t   TimeStampLow;          /*!< Time Stamp Low value for transmit and receive */
  uint32_t   TimeStampHigh;         /*!< Time Stamp High value for transmit and receive */
lwip generated checksums are all disabled, it's relying on the MAC to generate them

leap seconds:
nav-leap ublox msg?
look for a :60 seconds msg and jump the time?

ntp client::
ntp 10.1.2.198
rtt 275281 ns
v: 36 st: 1 id: 5460039 poll: 6 prec: -23
rdelay: 0.256 rdisp: 0.256
reftime: 3574481376.4036374221 origin: 0.0
rx: 3675144672.472069126 tx: 3675144672.4092936454
local rx: 17.165817452 ns

adjust counter speed::
-40511611+7387681
3762565112-3762564978
-33123930
134
-33123930/2^31
-.015424531/134
-.000115108*2^32
-494385.095507968
more negative: going too fast
4228489404-494385
4227995019

timestamp location:
stm32f407 TX timestamp on SFD (start frame delimiter)
stm32f407 RX timestamp on FCS start/payload end? SFD?
LeoBodnar| i don't think PTP cares - their reference point is start of packet for all timing
i211 seems to timestamp on the SFD end/start of packet
i211 has some jitter/latency between RX and TX path (~2us?)
NTP timestamps are on FCS start/packet end? https://www.eecis.udel.edu/~mills/stamp.html

NTP packet size:
Ethernet Preamble: 7 bytes
Ethernet SFD: 1 byte
- 1588 timestamp reference
Ethernet header: 14 bytes
IP header: 20 bytes
UDP header: 8 bytes
NTP: 48 bytes
Ethernet CRC: 4 bytes
- driver timestamp reference-ish
Ethernet IPG: 12 bytes

114*8
=912 bits

changing timestamp location based on packet size:
912/100000000
=.000009120 seconds per packet
100000000/912
109649 packets per second max

+/- 300ppm:
.000009117
.000009122
=5ns (~ +/- 3ns)

94*8
752 bits excluding preamble, SFD, IPG
752/100000000
.000007520
2x=15040
